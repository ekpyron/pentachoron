#version 420 core
layout(location = 0) out vec4 output;
layout(binding = 0) uniform sampler2D colorbuffer;
layout(binding = 1) uniform sampler2D glowbuffer;
layout(binding = 2) uniform sampler2D edgemap;
layout(binding = 3) uniform sampler2D depthmap;
uniform uvec2 viewport;
uniform int antialiasing;
uniform bool glow;
uniform float farClipPlane;
uniform float nearClipPlane;
uniform struct
{
	float image_key;
	float white_threshold;
	mat3x3 RGB2XYZ;
	mat3x3 XYZ2RGB;
	unsigned int mode;
	float sigma;
	float n;
} tonemapping;

float luminance (vec3 color)
{
	return 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;
}

float getdepth (vec2 coord)
{
	return 2.0 * nearClipPlane / (farClipPlane + nearClipPlane -
	       texture (depthmap, coord).r * (farClipPlane - nearClipPlane));
}

void main (void)
{
	vec4 color;
	float edge;
	vec2 coord = gl_FragCoord.xy / viewport;
	if (antialiasing > 0)
	{
		float depth = getdepth (coord);
		vec2 f = vec2 (1.0, 1.0) / viewport;
		float edgyness;
		edgyness = getdepth (coord + f * ivec2 (-1, -1))
			   - depth;
		edgyness += getdepth (coord + f * ivec2 (0, -1))
			    - depth;
		edgyness += getdepth (coord + f * ivec2 (1, -1))
			    - depth;
		edgyness += getdepth (coord + f * ivec2 (-1, 0))
			    - depth;
		edgyness += getdepth (coord + f * ivec2 (1, 0))
			    - depth;
		edgyness += getdepth (coord + f * ivec2 (-1, 1))
			    - depth;
		edgyness += getdepth (coord + f * ivec2 (0, 1))
			    - depth;
		edgyness += getdepth (coord + f * ivec2 (-1, 1))
			    - depth;

		edgyness *= 25;

		edgyness += texture (edgemap, coord).r * 2;
		if (edgyness > 0.25)
		{
		   float factor = 1.0 / float ((antialiasing * 2 + 1)
		   	 	      	      * (antialiasing * 2 + 1));
		   color = vec4 (0, 0, 0, 0);
		   for (int y = -antialiasing; y <= antialiasing; y++)
		   {
			for (int x = -antialiasing; x <= antialiasing; x++)
			{
		                vec2 offset = vec2 (x, y) / viewport;
				color += texture (colorbuffer, coord + offset)
				      	 * factor;
			}
		   }
		}
		else
		{
			color = texture (colorbuffer, coord);
		}
	}
	else
	{
		color = texture (colorbuffer, coord);
	}

	if (glow)
	{
		color.xyz += texture (glowbuffer, coord, 2).xyz;
	}

	float avgLuminance = 0.5;

	float exposure = tonemapping.image_key / avgLuminance;

	vec3 XYZ;

	XYZ = tonemapping.RGB2XYZ * color.xyz;

	vec3 Yxy;
	Yxy.r = XYZ.g;
	Yxy.g = XYZ.r / (XYZ.r + XYZ.g + XYZ.b);
	Yxy.b = XYZ.g / (XYZ.r + XYZ.g + XYZ.b);

	float Lp = Yxy.r * exposure / avgLuminance;

	Lp = pow (Lp, tonemapping.n);

	switch (tonemapping.mode)
	{
		case 0:
		     Yxy.r = (Lp * (1.0f + Lp
		     	     / (tonemapping.white_threshold
			        * tonemapping.white_threshold)))
	      		     / (tonemapping.sigma + Lp);

		break;
		case 1:
		     Yxy.r = log (1 + Lp)
		     	     / log (1 + tonemapping.white_threshold);
		break;
		case 2:
		     Yxy.r = tonemapping.sigma * Lp
		     	     / (tonemapping.sigma * Lp - Lp
			        + tonemapping.white_threshold);
		break;
		case 3:
		     Yxy.r = 1 - exp (-Lp);
		break;
	}

	XYZ.r = Yxy.r * Yxy.g / Yxy.b;
	XYZ.g = Yxy.r;
	XYZ.b = Yxy.r * (1 - Yxy.g - Yxy.b) / Yxy.b;

	color.xyz = tonemapping.XYZ2RGB * XYZ;
	color.w = 1.0;

	output = color;
}
