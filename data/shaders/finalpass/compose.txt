#version 420 core
layout(location = 0) out vec4 output;
layout(binding = 0) uniform sampler2D colorbuffer;
layout(binding = 1) uniform sampler2D glowbuffer;
layout(binding = 2) uniform sampler2DMS depthmap;
layout(binding = 3) uniform sampler2DMS normalmap;

uniform uvec2 viewport;
uniform uvec2 gbufferdim;
uniform uint antialiasing;
uniform bool glow;
uniform float farClipPlane;
uniform float nearClipPlane;
uniform struct
{
	float image_key;
	float white_threshold;
	mat3x3 RGB2XYZ;
	mat3x3 XYZ2RGB;
	float sigma;
	float n;
} tonemapping;

subroutine vec4 tonemapType (vec4 color);
subroutine uniform tonemapType tonemap;

vec3 RGB2Yxy (vec3 color)
{
	vec3 XYZ;

	XYZ = tonemapping.RGB2XYZ * color;

	vec3 Yxy;
	Yxy.r = XYZ.g;
	Yxy.g = XYZ.r / (XYZ.r + XYZ.g + XYZ.b);
	Yxy.b = XYZ.g / (XYZ.r + XYZ.g + XYZ.b);
	return Yxy;
}

vec3 Yxy2RGB (vec3 Yxy)
{
	vec3 XYZ;
	XYZ.r = Yxy.r * Yxy.g / Yxy.b;
	XYZ.g = Yxy.r;
	XYZ.b = Yxy.r * (1 - Yxy.g - Yxy.b) / Yxy.b;

	return tonemapping.XYZ2RGB * XYZ;
}

subroutine (tonemapType) vec4 tonemapDefault (vec4 color)
{
	return color;
}

subroutine (tonemapType) vec4 tonemapReinhard (vec4 color)
{
	float avgLuminance = 0.5;
	float exposure = tonemapping.image_key / avgLuminance;
	vec3 Yxy;
	Yxy = RGB2Yxy (color.xyz);
	float Lp = Yxy.r * exposure / avgLuminance;
	Lp = pow (Lp, tonemapping.n);
	Yxy.r = (Lp * (1.0f + Lp
     	      	/ (tonemapping.white_threshold
		  * tonemapping.white_threshold)))
	      	/ (tonemapping.sigma + Lp);
	return vec4 (Yxy2RGB (Yxy), 1.0);
}

subroutine (tonemapType) vec4 tonemapLogarithmic (vec4 color)
{
	float avgLuminance = 0.5;
	float exposure = tonemapping.image_key / avgLuminance;
	vec3 Yxy;
	Yxy = RGB2Yxy (color.xyz);
	float Lp = Yxy.r * exposure / avgLuminance;
	Lp = pow (Lp, tonemapping.n);
	Yxy.r = log (1 + Lp)
	      	/ log (1 + tonemapping.white_threshold);
	return vec4 (Yxy2RGB (Yxy), 1.0);
}

subroutine (tonemapType) vec4 tonemapURQ (vec4 color)
{
	float avgLuminance = 0.5;
	float exposure = tonemapping.image_key / avgLuminance;
	vec3 Yxy;
	Yxy = RGB2Yxy (color.xyz);
	float Lp = Yxy.r * exposure / avgLuminance;
	Lp = pow (Lp, tonemapping.n);
	Yxy.r = tonemapping.sigma * Lp
		/ (tonemapping.sigma * Lp - Lp
		   + tonemapping.white_threshold);
	return vec4 (Yxy2RGB (Yxy), 1.0);
}

subroutine (tonemapType) vec4 tonemapExponential (vec4 color)
{
	float avgLuminance = 0.5;
	float exposure = tonemapping.image_key / avgLuminance;
	vec3 Yxy;
	Yxy = RGB2Yxy (color.xyz);
	float Lp = Yxy.r * exposure / avgLuminance;
	Lp = pow (Lp, tonemapping.n);
        Yxy.r = 1 - exp (-Lp);
	return vec4 (Yxy2RGB (Yxy), 1.0);
}

void main (void)
{
	vec4 color;
	vec2 coord = gl_FragCoord.xy / viewport;

	if (antialiasing > 0)
	{
		ivec2 p = ivec2 (coord * gbufferdim);

		float weights[9] = { 0, 0, 0,
		      		     0, 0, 0,
				     0, 0, 0 };
		for (int s = 0; s < antialiasing; s++)
		{
			float d;
			vec3 N;
			d = texelFetch (depthmap, p, s).r;
			N = texelFetch (normalmap, p, s).xyz * 2 - 1;
			float tmpweights[9] = { 0, 0, 0,
			      		      	0, 0, 0,
						0, 0, 0 };
			float sum = 0.0f;
			for (int y = 0; y < 3; y++)
			{
				for (int x = 0; x < 3; x++)
				{
					float d2;
					vec3 N2;
					d2 = texelFetch (depthmap,
					   p + ivec2 (x - 1, y - 1), s).r;
					N2 = texelFetch (normalmap,
					   p + ivec2 (x - 1, y - 1), s).xyz * 2 - 1;
					float w = exp (-500 * max (abs (d - d2),
					      	       (1 - dot (N, N2))));
					tmpweights[x + y * 3] = w;
					sum += w;
				}
			}
			for (int i = 0; i < 9; i++)
			{
				weights[i] += tmpweights[i] / sum;
			}
		}

		color = vec4 (0, 0, 0, 0);
		for (int y = 0; y < 3; y++)
		{
			for (int x = 0; x < 3; x++)
			{
				color += weights[x + y * 3]
				* texture (colorbuffer, coord
			  	    + vec2 (x - 1, y - 1) / gbufferdim)
				/ antialiasing;
			}
		}
	}
	else
	{
		color = texture (colorbuffer, coord);
	}

	if (glow)
	{
		color.xyz += texture (glowbuffer, coord).xyz;
	}

	output = tonemap (color);
}
