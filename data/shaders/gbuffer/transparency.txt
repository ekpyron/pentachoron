/*  
 * This file is part of DRE.
 *
 * DRE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * DRE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DRE.  If not, see <http://www.gnu.org/licenses/>.
 */
/* #version 430 core [specified externally] */
/*
 * external definitions:
 * GBUFFER_WIDTH
 * GBUFFER_HEIGHT
 */

struct Fragment {
       uint color;
       uint specular;
       uint normal;
       float depth;
       int next;
};

writeonly layout (std430, binding = 4) buffer FragmentList {
       struct Fragment fragments[];
};

layout (std430, binding = 3) buffer FragmentIndex {
       int fragindices[];
};

// atomic counters
layout (binding = 0) uniform atomic_uint counter[64];

// texture input
layout(binding = 0) uniform sampler2D diffusemap;
layout(binding = 1) uniform sampler2D normalmap;
layout(binding = 2) uniform sampler2D specularmap;
layout(binding = 3) uniform sampler2D parametermap;

// uniform input
uniform bool diffuse_enabled;
uniform bool normalmap_enabled;
uniform bool specularmap_enabled;
uniform bool parametermap_enabled;

// texture coordinates
in vec2 uv;

// tangent space base vectors
smooth in vec3 fTangent;
smooth in vec3 fBinormal;
smooth in vec3 fNormal;

// early depth reject assures only visible
// fragments will be written to the list
layout (early_fragment_tests) in;

void main (void)
{
	vec4 color, specular, normal;
	ivec2 p = ivec2 (gl_FragCoord.xy);

	// fetch diffuse color
	if (diffuse_enabled)
		color = texture2D (diffusemap, uv);
	else
		color = vec4 (0.0, 0.0, 0.0, 1.0);

	// fetch specular color
	if (specularmap_enabled)
		specular.xyz = texture2D (specularmap, uv).xyz;
	else
		specular.xyz = color.xyz;

	// fetch normal
	if (normalmap_enabled)
	{
		vec3 n;
		mat3x3 tangentmat;
		n.xy = texture2D (normalmap, uv).xy * 2.0 - 1.0;
		// reconstruct z coordinate
		n.z = sqrt (1.0 - n.x * n.x - n.y * n.y);
		// convert to tangent space
		tangentmat = mat3x3 (fTangent, fBinormal, fNormal);
		normal.xyz = (tangentmat * n) * 0.5 + 0.5;
	}
	else
	{
		normal.xyz = fNormal * 0.5 + 0.5;
	}

	// fetch material parameter information
	if (parametermap_enabled)
	{
		specular.w = texture2D (parametermap, uv).r;
	}
	else
	{
		specular.w = 0;
	}

	// decide which counter to use
	int counterid;
	counterid = int (gl_FragCoord.x) & 7;
	counterid += 8 * (int (gl_FragCoord.y) & 7);

	// increase counter
	int idx = int (atomicCounterIncrement (counter[counterid]));
	// compute linear buffer index
	idx *= 64;
	idx += counterid;

	// replace the starting index
	int next = atomicExchange (fragindices[p.y * GBUFFER_WIDTH
	    	   		  	       + p.x], idx);

	// store data to linear buffer
	fragments[idx].color = packUnorm4x8 (color);
	fragments[idx].specular = packUnorm4x8 (specular);
	fragments[idx].normal = packUnorm4x8 (normal);
	fragments[idx].depth = gl_FragCoord.z;
	fragments[idx].next = next;
}
